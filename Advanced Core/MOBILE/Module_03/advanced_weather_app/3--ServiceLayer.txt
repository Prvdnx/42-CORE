Service Layer - Complete Breakdown

### The "Why"

The service layer is a crucial part of any well-structured application. Its purpose is to isolate all communication with the outside world (like web APIs or device hardware) from the rest of your application. This separation of concerns makes your code much cleaner, easier to test, and easier to maintain. Instead of having API fetching logic scattered throughout your UI components, it's all centralized here.

This project has three distinct services, each with a specific job.

---

### 1. `LocationService.js` - The Simplest Service

**Purpose:** This service is responsible for a single task: getting the user's current GPS coordinates from the device.

**Code Breakdown:**

*   **`getCurrentPosition()`**: This is the only function in the service. It is an `async` function, which means it will return a `Promise` that eventually resolves with the location data.
    *   **Permissions First**: The first thing it does is call `Location.getForegroundPermissionsAsync()`. This is a crucial step for privacy and functionality. It checks if the app *already* has permission to access the user's location.
    *   **Requesting Permission**: If the permission status is not `'granted'`, it then calls `Location.requestForegroundPermissionsAsync()`. This is what triggers the native iOS or Android dialog box that asks the user, "Allow WeatherApp to use your location?"
    *   **Handling Denial**: If the user denies the request, the status will still not be `'granted'`, and the function throws an error. This error is then caught by the `askForGeolocation` function in `App.js`, which knows to set `isLocationDenied` to `true`.
    *   **Getting the Position**: If permission is granted, it calls `Location.getCurrentPositionAsync()`. This is the function that actually turns on the GPS hardware and gets the coordinates.
    *   **Returning Data**: Finally, it returns a simple object containing just the `latitude` and `longitude`. It intentionally does not return the full, complex location object from the Expo library, keeping the data clean and minimal.

---

### 2. `GeocodingService.js` - The Translator

**Purpose:** This service has two related but distinct jobs, both involving the translation between human-readable names and machine-readable coordinates.

**Code Breakdown:**

*   **`_fetchAPI()`**: This is a private helper function (indicated by the `_` prefix). It takes a URL and an options object and handles the boilerplate logic of using `fetch`, checking if the response was successful, and parsing the JSON. This is a great example of the **Don't Repeat Yourself (DRY)** principle in action.

*   **`searchCities(query)`**: This function powers the search bar's suggestion list.
    *   It takes a search `query` (like "London").
    *   It constructs a URL for the Open-Meteo Geocoding API.
    *   It calls the `_fetchAPI` helper to get the data.
    *   It then **transforms** the raw API results into a cleaner, more usable format. Notice how it creates a `displayName` property to provide a nicely formatted string for the UI (`London, England`), which is easier to work with than concatenating the parts in the UI code.

*   **`getLocationName(latitude, longitude)`**: This function does the reverse of `searchCities`. It's used when you have GPS coordinates and want to show the user a human-readable name.
    *   It takes a `latitude` and `longitude`.
    *   It constructs a URL for the **Nominatim (OpenStreetMap)** API, which is a free and open reverse geocoding service.
    *   It calls `_fetchAPI` to get the address details.
    *   It then carefully extracts the city, region, and country from the complex address object returned by the API.
    *   **Fallback Logic**: If the API fails or doesn't return a useful address (e.g., if you're in the middle of the ocean), it calls `formatCoordinatesDisplay` as a fallback.

*   **`formatCoordinatesDisplay()`**: This is a crucial fallback function. If a location name can't be found, it ensures the app still works by returning a standard object with the `displayName` set to "Current Location".

---

### 3. `WeatherService.js` - The Main Data Provider

**Purpose:** This is the most important service. It is responsible for fetching all the actual weather data for the application.

**Code Breakdown:**

*   **`_fetchWeatherData()`**: Just like in the `GeocodingService`, this private helper function centralizes the `fetch` logic for the Open-Meteo weather API. It takes the coordinates and a `params` string, which makes it very flexible.

*   **`getCurrentWeather()`**, **`getTodayForecast()`**, **`getWeeklyForecast()`**: These three functions are the public face of the service. Each one is responsible for getting a specific piece of weather data.
    *   **Parameter Definition**: Each function defines the specific `params` string required by the Open-Meteo API for the data it needs (e.g., `current=temperature_2m` for the current weather).
    *   **Calling the Helper**: Each function `await`s the result of the `_fetchWeatherData` helper.
    *   **Data Transformation**: This is a key step. The raw data from the API is often not in a perfect format for a UI. These functions clean it up.
        *   They use `Math.round()` to get rid of unnecessary decimal places.
        *   They use `.map()` to transform the hourly and daily forecast arrays into clean arrays of objects with clear property names (`maxTemp`, `minTemp`, etc.).
        *   They call `getWeatherDescription()` to convert the numeric weather code from the API into a human-readable string like "Partly cloudy".

*   **`getWeatherDescription(code)`**: A simple but important helper function that acts as a dictionary to translate the weather codes (like `3`) into meaningful text (`Overcast`).

### In Summary

The service layer acts as a clean, well-defined boundary between your application's internal logic and the messy, unpredictable outside world. It fetches and, most importantly, **transforms** data into a clean, consistent format that the rest of your app can easily use without needing to know the complex details of the APIs it came from.
