The best place to start is the "brain" of the application: App.js. This file is responsible for managing all the application's state, fetching data, and passing that data down to the correct components.


App.js - Complete Breakdown

### The "Why"

This file acts as the central hub for the entire application. It holds the most important pieces of information and orchestrates how the different parts of the app talk to each other.

### Code Breakdown

#### 1. State Management (`useState`)

At the very top of the `App` component, you'll see a series of `useState` hooks. These are the memory of your application.

*   `searchText`, `isGeolocation`, `activeTab`: These manage the UI state. What text is in the search bar? Are we using GPS? Which tab is currently visible?
*   `selectedLocation`, `weatherData`: This is the core **data** for the app. `selectedLocation` holds the coordinates and name of the place we're showing weather for, and `weatherData` holds the results from the weather API for all three tabs (current, today, weekly).
*   `appState`: This object groups together all the "status" information. Is the app currently loading location? Is it loading weather? Has permission been denied? Is there an error? This is a clean way to manage related state variables.

#### 2. Data Flow (`loadWeatherData` and `handleError`)

*   `loadWeatherData`: This is a crucial function. Its job is to take a `location` object, fetch all the necessary weather data from the `WeatherService`, and then update the `weatherData` state. Notice that it uses `Promise.all` to fetch the data for all three screens at the same time, which is very efficient.
*   `handleError`: A simple helper function to manage the different error states.

#### 3. Lifecycle (`useEffect`)

The `useEffect` hook is how the app handles events that happen "outside" of the normal render cycle. In this case, it's used for one critical purpose:

*   **Initial Geolocation**: The `useEffect` with an empty dependency array `[]` runs only once, when the app first starts. It calls `askForGeolocation`, which uses the `LocationService` and `GeocodingService` to get the user's initial position and then calls `loadWeatherData` to fetch the weather for that spot.

#### 4. Component Assembly (The `return` statement)

This is where the UI is put together.

*   `TopBar`: This is the search bar and geolocation button at the top. Notice that it is given a series of **callbacks** as props (like `onLocationSelected` and `onLocationDenied`). This is how a child component communicates back up to its parent. When you select a city in the `TopBar`, it calls `onLocationSelected` with the new location, which then triggers a data reload in `App.js`.
*   `PagerView` and `SCREENS.map`: This is how the three main screens are created. The code maps over the `SCREENS` array and creates a `<View>` with the correct screen component (`CurrentlyScreen`, `TodayScreen`, etc.) for each item in the array.
*   **Props to Screens**: Pay close attention to the props being passed down to each screen. Each screen receives the specific piece of `weatherData` it needs, the `locationData`, and all the status variables like `isLoading` and `isLocationDenied`.
*   **Bottom Tab Bar**: This also maps over the `SCREENS` array to create the touchable buttons for each tab, ensuring the UI is always in sync with the screen configuration.

### In Summary

Think of `App.js` as the "main function" of your UI. It initializes the state, fetches the initial data, and then renders the main components, passing down the data and functions they need to do their jobs.
